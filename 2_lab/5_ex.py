import math
from memory_profiler import profile

# Функция для определения расстояния между двумя точками
def distance(p1, p2):
    return math.sqrt((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2)

# Функция для определения направления поворота
def orientation(p, q, r):
    val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])
    if val == 0:
        return 0  # Точки коллинеарны
    return 1 if val > 0 else -1  # 1 - по часовой стрелке, -1 - против часовой стрелки

@profile
# Функция для нахождения периметра выпуклой оболочки
def convex_hull_perimeter(points):
    n = len(points)
    if n < 3:
        return 0

    hull = []
    # Находим точку с наименьшей координатой y (и самой левой, если таких несколько)
    start = min(points, key=lambda p: (p[1], p[0]))

    # Сортируем остальные точки по углу, который они образуют с выбранной точкой
    sorted_points = sorted(points, key=lambda p: (math.atan2(p[1] - start[1], p[0] - start[0]), distance(start, p)))

    for p in sorted_points:
        while len(hull) > 1 and orientation(hull[-2], hull[-1], p) != -1:
            hull.pop()
        hull.append(p)

    perimeter = sum(distance(hull[i], hull[(i + 1) % len(hull)]) for i in range(len(hull)))

    return perimeter

# Исходные данные
points = [
    [2, 1],
    [2, 2],
    [2, 3],
    [3, 2],
    [1, 2]
]

# Вызов функции для нахождения периметра выпуклой оболочки
result = convex_hull_perimeter(points)
print(result)



"""Алгоритм оболочки Грэхема (Graham's scan) — это алгоритм для нахождения выпуклой оболочки заданного набора точек на плоскости. Выпуклая оболочка - это наименьший выпуклый многоугольник, содержащий все точки из исходного набора.

Вот как работает алгоритм оболочки Грэхема:

1. Находим точку с самой низкой y-координатой (и самой левой в случае равенства) - это будет начальная точка оболочки.
2. Сортируем остальные точки по полярному углу, который они образуют с начальной точкой (относительно оси x).
3. Проходим отсортированный список точек и добавляем каждую точку в оболочку. При этом проверяем, что предыдущие две точки и текущая точка образуют поворот по часовой стрелке. Если это не так, удаляем последнюю добавленную точку из оболочки и повторяем проверку для предыдущих точек.
4. После прохода по всем точкам, получаем выпуклую оболочку в виде списка точек.

Для нахождения периметра выпуклой оболочки можно пройти по найденным точкам и посчитать сумму расстояний между каждой парой последовательных точек.

Этот алгоритм эффективен и имеет временную сложность O(n log n), где n - количество точек, так как основное время занимает сортировка точек по полярному углу."""